rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============ CORE PRODUCT MANAGEMENT ============
    // Products - Enhanced rules for seller edit/delete functionality
    match /products/{productId} {
      // Anyone can read products (for browsing/shopping)
      allow read: if true;
      
      // Only authenticated artisans can create products with their own artisanId
      allow create: if request.auth != null && 
                   request.auth.uid == request.resource.data.artisanId &&
                   validateProductData(request.resource.data);
      
      // Allow product owner updates OR likes/views updates by any authenticated user OR rating updates by system OR inventory updates during orders
      allow update: if request.auth != null && (
                   // Product owner can update everything
                   (request.auth.uid == resource.data.artisanId &&
                    validateProductUpdate(request.resource.data, resource.data)) ||
                   // Any authenticated user can update likes and views
                   validateLikesViewsUpdate(request.resource.data, resource.data) ||
                   // System can update rating statistics
                   onlyUpdatingRatingFields(request.resource.data, resource.data) ||
                   // Allow inventory updates during order placement
                   validateInventoryUpdate(request.resource.data, resource.data)
                   );
      
      // Only the product owner (artisan) can delete their products
      allow delete: if request.auth != null && 
                   request.auth.uid == resource.data.artisanId;
    }
    
    // ============ USER PROFILE MANAGEMENT ============
    // Sellers/Artisans - Enhanced profile management with dual account support
    match /sellers/{sellerId} {
      // Anyone can read seller profiles (for discovery)
      allow read: if true;
      
      // Allow creation/update if:
      // 1. Regular account: sellerId matches authenticated UID
      // 2. Dual account: sellerId starts with authenticated UID followed by '_retailer'
      allow create, update: if request.auth != null && 
                           (request.auth.uid == sellerId ||
                            sellerId == request.auth.uid + '_retailer');
      
      // Allow deletion with same logic as create/update
      allow delete: if request.auth != null && 
                   (request.auth.uid == sellerId ||
                    sellerId == request.auth.uid + '_retailer');
    }
    
    // Stores - Enhanced store management for sellers with dual account support
    match /stores/{storeId} {
      // Anyone can read store information
      allow read: if true;
      
      // Allow management if:
      // 1. Regular account: storeId matches authenticated UID
      // 2. Dual account: storeId starts with authenticated UID
      allow create, update, delete: if request.auth != null && 
                                   (request.auth.uid == storeId ||
                                    storeId == request.auth.uid + '_retailer');
    }
    
    // Customers - Customer profile management with dual account support
    match /customers/{customerId} {
      // Customers can read any customer profile (for social features)
      allow read: if request.auth != null;
      
      // Allow management if:
      // 1. Regular account: customerId matches authenticated UID
      // 2. Dual account: customerId starts with authenticated UID followed by '_customer'
      allow create, update, delete: if request.auth != null && 
                                   (request.auth.uid == customerId ||
                                    customerId == request.auth.uid + '_customer');
      
      // Customer subcollections (cart, favorites, etc.)
      match /{subcollection=**} {
        allow read, write: if request.auth != null && 
                          (request.auth.uid == customerId ||
                           customerId == request.auth.uid + '_customer');
      }
    }
    
    // Users - General user profiles and authentication data with dual account support
    match /users/{userId} {
      // Users can read any user profile (for social features)
      allow read: if request.auth != null;
      
      // Allow management if:
      // 1. Regular account: userId matches authenticated UID
      // 2. Dual account: userId starts with authenticated UID
      allow create, update, delete: if request.auth != null && 
                                   (request.auth.uid == userId ||
                                    userId.matches(request.auth.uid + '_.*'));
      
      // User subcollections with dual account support
      match /{subcollection=**} {
        allow read, write: if request.auth != null && 
                          (request.auth.uid == userId ||
                           userId.matches(request.auth.uid + '_.*'));
      }
    }

    // ============ RETAILERS COLLECTION ============
    // Add specific collection for retailers with dual account support
    match /retailers/{retailerId} {
      // Anyone can read retailer profiles (for discovery)
      allow read: if true;
      
      // Allow creation/update if:
      // 1. Regular account: retailerId matches authenticated UID
      // 2. Dual account: retailerId starts with authenticated UID followed by '_retailer'
      allow create, update: if request.auth != null && 
                           (request.auth.uid == retailerId ||
                            retailerId == request.auth.uid + '_retailer');
      
      // Allow deletion with same logic as create/update
      allow delete: if request.auth != null && 
                   (request.auth.uid == retailerId ||
                    retailerId == request.auth.uid + '_retailer');
    }
    
    // ============ ORDER AND TRANSACTION MANAGEMENT ============
    match /orders/{orderId} {
  // Allow creation if user is authenticated
  allow create: if request.auth != null;
  
  // Allow read if user is buyer OR any artisan in the items array
  allow read: if request.auth != null && (
    request.auth.uid == resource.data.buyerId ||
    userIsArtisanInOrderItems(request.auth.uid, resource.data.items)
  );
  
  // Allow update if user is buyer OR any artisan in the items array
  allow update: if request.auth != null && (
    request.auth.uid == resource.data.buyerId ||
    userIsArtisanInOrderItems(request.auth.uid, resource.data.items)
  );
  
  // Allow delete only by buyer
  allow delete: if request.auth != null && 
    request.auth.uid == resource.data.buyerId;
}
// CORRECTED Helper function to check if user is an artisan in any order item
function userIsArtisanInOrderItems(userId, items) {
  return items != null && 
         items is list && 
         items.size() > 0 &&
         existsIn(items, userId);
}

// Helper function to check if userId exists as artisanId in any item
function existsIn(items, userId) {
  return items.hasAny([userId]) || 
         checkItemsForArtisan(items, userId, 0);
}

// Recursive function to check items array
function checkItemsForArtisan(items, userId, index) {
  return index < items.size() && 
         (items[index].artisanId == userId || 
          checkItemsForArtisan(items, userId, index + 1));
}
    
    // Quotations - For craft requests and custom orders
    match /quotations/{quotationId} {
      // Anyone can read quotations (for browsing)
      allow read: if true;
      
      // Authenticated users can create quotations
      allow create: if request.auth != null;
      
      // Quotation creator and related parties can update
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.artisanId ||
         request.auth.uid == resource.data.customerId ||
         request.auth.uid == resource.data.sellerId);
      
      // Quotation creator can delete
      allow delete: if request.auth != null && 
                   request.auth.uid == resource.data.artisanId;
    }
    
    // Daily Revenue - For seller analytics
    match /daily_revenue/{revenueId} {
      // Only the seller can read their own revenue data
      allow read, write: if request.auth != null && 
                        request.auth.uid == resource.data.sellerId;
      
      // Allow creation of revenue records
      allow create: if request.auth != null;
    }
    
    // ============ REVIEWS AND RATINGS ============
    // ...existing code...
    match /reviews/{reviewId} {
      // Anyone can read reviews
      allow read: if true;
      
      // Only buyers can create reviews for their orders
      allow create: if request.auth != null && 
                   request.auth.uid == request.resource.data.buyerId;
      
      // Buyers can update their own reviews, sellers can respond
      allow update: if request.auth != null && 
                   (request.auth.uid == resource.data.buyerId ||
                    request.auth.uid == resource.data.sellerId);
      
      // Only review author can delete
      allow delete: if request.auth != null && 
                   request.auth.uid == resource.data.buyerId;
    }
    
    // ============ FAVORITES AND SOCIAL FEATURES ============
    // ...existing code...
    match /favorites/{favoriteId} {
      // Users can only manage their own favorites
      allow read, write: if request.auth != null && 
                        request.auth.uid == resource.data.userId;
    }
    
    // User activity and engagement
    match /user_activity/{activityId} {
      allow read, write: if request.auth != null && 
                        request.auth.uid == resource.data.userId;
    }
    
    // User activities collection (alternative naming)
    match /user_activities/{activityId} {
      allow read, write: if request.auth != null && 
                        request.auth.uid == resource.data.userId;
      // Allow creation if user is authenticated
      allow create: if request.auth != null && 
                   request.auth.uid == request.resource.data.userId;
    }
    
    // ============ COMMUNICATION ============
    // ...existing code...
    match /chat_rooms/{chatRoomId} {
      // Only chat participants can access
      allow read, write: if request.auth != null && 
        (request.auth.uid in resource.data.participants||
         request.auth.uid == resource.data.customerId || 
         request.auth.uid == resource.data.artisanId ||
         request.auth.uid == resource.data.sellerId);
      
      // Messages within chat rooms
      match /messages/{messageId} {
        allow read, write: if request.auth != null && 
          (request.auth.uid == get(/databases/$(database)/documents/chat_rooms/$(chatRoomId)).data.customerId ||
           request.auth.uid == get(/databases/$(database)/documents/chat_rooms/$(chatRoomId)).data.artisanId ||
           request.auth.uid == get(/databases/$(database)/documents/chat_rooms/$(chatRoomId)).data.sellerId);
      }
    }
    
    // Conversations - Enhanced messaging
    match /conversations/{conversationId} {
      allow read, write: if request.auth != null && 
                        request.auth.uid in resource.data.participants;
      
      match /messages/{messageId} {
        allow read, write: if request.auth != null && 
                          request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
      }
    }
    
    // Notifications
    match /notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if request.auth != null && 
                 request.auth.uid == resource.data.userId;
      
      // Allow creating and updating notifications for the target user
      allow create, update: if request.auth != null && 
                           request.auth.uid == request.resource.data.userId;
      
      // Allow system or other users to create notifications for a user
      allow create: if request.auth != null;
      
      // Users can update/delete their own notifications
      allow update, delete: if request.auth != null && 
                           request.auth.uid == resource.data.userId;
    }

    // FCM Token refresh requests - Fix for token refresh loop
    match /token_refresh_requests/{requestId} {
      // Cloud Functions can create token refresh requests for any user
      allow create: if request.auth != null;
      
      // Users can read their own token refresh requests
      allow read: if request.auth != null && 
                 request.auth.uid == resource.data.userId;
      
      // Users can update their own token refresh requests (to mark completed/failed)
      allow update: if request.auth != null && 
                   request.auth.uid == resource.data.userId;
      
      // Allow Cloud Functions to read all requests for processing
      allow read: if request.auth != null;
      
      // Auto-cleanup: Allow deletion of old requests
      allow delete: if request.auth != null;
    }
    
    // ============ CRAFT REQUESTS ============
    // ...existing code...
    match /craft_requests/{requestId} {
      // Anyone can read requests (for discovery/browsing)
      allow read: if true;
      
      // Only authenticated users can create requests
      allow create: if request.auth != null && 
                   request.auth.uid == request.resource.data.buyerId &&
                   validateCraftRequestData(request.resource.data);
      
      // Buyers can update their own requests
      // Any authenticated user can update to add quotations (app logic handles validation)
      allow update: if request.auth != null;
      
      // Buyers can delete their own requests
      allow delete: if request.auth != null && 
                   request.auth.uid == resource.data.buyerId;
    }
    // ============ COLLABORATION SYSTEM ============
match /collaboration_projects/{projectId} {
  // Allow read if project is open OR user is involved
  allow read: if resource.data.status == 'open' || 
             (request.auth != null && 
              (request.auth.uid == resource.data.buyerId ||
               request.auth.uid == resource.data.leadArtisanId ||
               request.auth.uid in resource.data.get('collaboratorIds', [])));
  
  // Allow creation by lead artisan
  allow create: if request.auth != null && 
               request.auth.uid == request.resource.data.leadArtisanId &&
               validateCollaborationProjectData(request.resource.data);
  
  // Allow updates by project participants
  allow update: if request.auth != null && 
               (request.auth.uid == resource.data.buyerId ||
                request.auth.uid == resource.data.leadArtisanId ||
                request.auth.uid in resource.data.get('collaboratorIds', [])) &&
               validateCollaborationProjectUpdate(request.resource.data, resource.data);
  
  // Allow deletion by buyer or lead artisan
  allow delete: if request.auth != null && 
               (request.auth.uid == resource.data.buyerId ||
                request.auth.uid == resource.data.leadArtisanId);
  
  // Project Applications subcollection
  match /applications/{applicationId} {
    // Allow read if project is open OR user is involved
    allow read: if (get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.status == 'open') ||
               (request.auth != null && 
                (request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.buyerId ||
                 request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.leadArtisanId ||
                 request.auth.uid == resource.data.artisanId));
    
    // Allow creation by authenticated users for open projects
    allow create: if request.auth != null && 
                 request.auth.uid == request.resource.data.artisanId &&
                 get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.status == 'open' &&
                 validateApplicationData(request.resource.data);
    
    // Allow updates by project lead or applicant
    allow update: if request.auth != null && 
                 (request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.buyerId ||
                  request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.leadArtisanId ||
                  (request.auth.uid == resource.data.artisanId && resource.data.status == 'pending'));
    
    // Allow deletion by applicant if pending
    allow delete: if request.auth != null && 
                 request.auth.uid == resource.data.artisanId &&
                 resource.data.status == 'pending';
  }
  
  // Project Tasks subcollection
  match /tasks/{taskId} {
    // Allow read by project participants
    allow read: if request.auth != null && 
               (request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.buyerId ||
                request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.leadArtisanId ||
                request.auth.uid in get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.get('collaboratorIds', []));
    
    // Allow creation/update by lead artisan or buyer
    allow create, update: if request.auth != null && 
                         (request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.buyerId ||
                          request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.leadArtisanId);
    
    // Allow updates by assigned collaborator for status changes
    allow update: if request.auth != null && 
                 request.auth.uid == resource.data.get('assignedTo', '') &&
                 validateTaskStatusUpdate(request.resource.data, resource.data);
    
    // Allow deletion by lead artisan or buyer
    allow delete: if request.auth != null && 
                 (request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.buyerId ||
                  request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.leadArtisanId);
  }
  
  // Project Messages subcollection
  match /messages/{messageId} {
    // Allow read by project participants
    allow read: if request.auth != null && 
               (request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.buyerId ||
                request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.leadArtisanId ||
                request.auth.uid in get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.get('collaboratorIds', []));
    
    // Allow creation by project participants
    allow create: if request.auth != null && 
                 request.auth.uid == request.resource.data.senderId &&
                 (request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.buyerId ||
                  request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.leadArtisanId ||
                  request.auth.uid in get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.get('collaboratorIds', []));
    
    // Allow updates by message sender
    allow update: if request.auth != null && 
                 request.auth.uid == resource.data.senderId;
    
    // Allow deletion by sender, buyer, or lead artisan
    allow delete: if request.auth != null && 
                 (request.auth.uid == resource.data.senderId ||
                  request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.buyerId ||
                  request.auth.uid == get(/databases/$(database)/documents/collaboration_projects/$(projectId)).data.leadArtisanId);
  }
}
// Collaboration chat rooms
    match /collaboration_chats/{chatRoomId} {
      allow read, write: if request.auth != null && 
        (isCollaborationMember(chatRoomId) || isProjectLeader(chatRoomId));
    }
    
    // Collaboration chat messages
    match /collaboration_chats/{chatRoomId}/messages/{messageId} {
      allow read, write: if request.auth != null && 
        (isCollaborationMember(chatRoomId) || isProjectLeader(chatRoomId));
    }
    
    // Helper functions for collaboration permissions
    function isCollaborationMember(chatRoomId) {
      let collaborationId = getCollaborationIdFromChatRoom(chatRoomId);
      let collaborationDoc = get(/databases/$(database)/documents/collaboration_projects/$(collaborationId));
      return collaborationDoc != null && 
        (collaborationDoc.data.collaboratorIds.hasAny([request.auth.uid]) ||
         collaborationDoc.data.leadArtisanId == request.auth.uid);
    }
    
    function isProjectLeader(chatRoomId) {
      let collaborationId = getCollaborationIdFromChatRoom(chatRoomId);
      let collaborationDoc = get(/databases/$(database)/documents/collaboration_projects/$(collaborationId));
      return collaborationDoc != null && 
        collaborationDoc.data.leadArtisanId == request.auth.uid;
    }
    
    function getCollaborationIdFromChatRoom(chatRoomId) {
      // Extract collaboration ID from chat room formats:
      // team_COLLABORATION_ID -> COLLABORATION_ID
      // direct_COLLABORATION_ID_USER1_USER2 -> COLLABORATION_ID
      return chatRoomId.matches('team_.*') ? 
        chatRoomId.replace('team_', '') :
        chatRoomId.matches('direct_.*') ?
          chatRoomId.split('_')[1] : '';
    }
// Add these validation functions after validateCraftRequestData function:

function validateCollaborationProjectData(data) {
  return data.keys().hasAll(['leadArtisanId', 'title', 'description', 'totalBudget', 'deadline', 'category', 'requiredRoles']) &&
         data.leadArtisanId is string && data.leadArtisanId.size() > 0 &&
         data.title is string && data.title.size() > 0 &&
         data.description is string && data.description.size() > 0 &&
         data.totalBudget is number && data.totalBudget > 0 &&
         data.deadline is timestamp &&
         data.category is string && data.category.size() > 0 &&
         data.requiredRoles is list && data.requiredRoles.size() > 0 &&
         data.status in ['open', 'in_progress', 'completed', 'cancelled'];
}

function validateCollaborationProjectUpdate(newData, existingData) {
  return newData.leadArtisanId == existingData.leadArtisanId &&
         newData.diff(existingData).affectedKeys().hasOnly([
           'title', 'description', 'totalBudget', 'deadline', 'status', 
           'collaboratorIds', 'progressPercentage', 'budgetAllocation', 
           'updatedAt', 'additionalNotes', 'requirements', 'tags', 
           'complexity', 'urgency', 'isUrgent', 'allowPartialDelivery', 
           'requireQualitySamples', 'attachments', 'requiredRoles'
         ]);
}

function validateApplicationData(data) {
  return data.keys().hasAll(['artisanId', 'proposal', 'proposedRate', 'estimatedDays']) &&
         data.artisanId is string && data.artisanId.size() > 0 &&
         data.proposal is string && data.proposal.size() > 0 &&
         data.proposedRate is number && data.proposedRate > 0 &&
         data.estimatedDays is number && data.estimatedDays > 0 &&
         data.status in ['pending', 'accepted', 'rejected'];
}

function validateTaskStatusUpdate(newData, existingData) {
  return newData.diff(existingData).affectedKeys().hasOnly(['status', 'completedAt', 'notes', 'progress', 'updatedAt']) &&
         newData.id == existingData.id &&
         newData.assignedTo == existingData.assignedTo;
}

    // ============ ADMINISTRATIVE AND SYSTEM ============
    // ...existing code...
    match /categories/{categoryId} {
      allow read: if true;
      allow write: if false; // Admin/system only
    }
    
    // Analytics - System-level analytics
    match /analytics/{analyticsId} {
      allow read: if request.auth != null;
      allow write: if false; // System only
    }
    
    // Promotions and marketing
    match /promotions/{promotionId} {
      allow read: if true;
      allow write: if false; // Admin only
    }
    
    // System configuration
    match /system_config/{configId} {
      allow read: if request.auth != null;
      allow write: if false; // Admin only
    }
    
    // ============ VALIDATION FUNCTIONS ============
    // Helper functions for data validation
    function validateProductData(data) {
      return data.keys().hasAll(['name', 'description', 'price', 'artisanId', 'category']) &&
             data.name is string && data.name.size() > 0 &&
             data.description is string && data.description.size() > 0 &&
             data.price is number && data.price > 0 &&
             data.artisanId is string && data.artisanId.size() > 0 &&
             data.category is string && data.category.size() > 0;
    }
    
    function validateProductUpdate(newData, existingData) {
      // Ensure critical fields aren't changed maliciously
      return newData.artisanId == existingData.artisanId &&
             // Allow normal field updates including Artisan's Legacy fields
             (newData.diff(existingData).affectedKeys().hasOnly(['name', 'description', 'price', 'stockQuantity', 'materials', 'tags', 'category', 'dimensions', 'craftingTime', 'careInstructions', 'isActive', 'updatedAt', 'imageUrl', 'imageUrls', 'videoUrl', 'audioStoryUrl', 'audioStoryTranscription', 'audioStoryTranslations', 'aiAnalysis', 'searchTerms', 'priceRange', 'views', 'likes', 'likedBy', 'artisanLegacyStory', 'storyIngredients', 'provenanceMapData']));
    }
    
    function validateLikesViewsUpdate(newData, existingData) {
      // Only allow updates to likes, likedBy, and views fields
      return newData.diff(existingData).affectedKeys().hasOnly(['likes', 'likedBy', 'views']) &&
             // Ensure artisanId and other critical fields remain unchanged
             newData.artisanId == existingData.artisanId &&
             newData.name == existingData.name &&
             newData.price == existingData.price;
    }
    
    function validateCraftRequestData(data) {
      return data.keys().hasAll(['buyerId', 'title', 'description', 'budget']) &&
             data.buyerId is string && data.buyerId.size() > 0 &&
             data.title is string && data.title.size() > 0 &&
             data.description is string && data.description.size() > 0 &&
             data.budget is number && data.budget > 0;
    }
    
    // ============ CHAT SYSTEM ============
    // ...existing code...
    match /chat_rooms/{chatRoomId} {
      allow read, write: if request.auth != null;
      allow create: if request.auth != null;
        
      // Messages subcollection
      match /messages/{messageId} {
        allow read, write: if request.auth != null;
        allow create: if request.auth != null;
      }
    }
    
    // ============ LIVING WORKSHOPS ============
    // ...existing code...
    match /living_workshops/{workshopId} {
      // Anyone can read workshops for public viewing experiences
      allow read: if true;
      
      // Only authenticated users can create workshops with their own userId
      allow create: if request.auth != null && 
                   (request.auth.uid == workshopId || 
                    request.auth.uid == request.resource.data.userId ||
                    request.auth.uid == request.resource.data.artisanId);
      
      // Only the workshop owner can update their workshop
      allow update: if request.auth != null && 
                   (request.auth.uid == workshopId ||
                    request.auth.uid == resource.data.userId ||
                    request.auth.uid == resource.data.artisanId);
      
      // Only the workshop owner can delete their workshop
      allow delete: if request.auth != null && 
                   (request.auth.uid == workshopId ||
                    request.auth.uid == resource.data.userId ||
                    request.auth.uid == resource.data.artisanId);
    }
    
    // ============ REVIEWS AND RATINGS SYSTEM ============
    // Reviews collection rules
    match /reviews/{reviewId} {
      // Allow read access to all authenticated users
      allow read: if request.auth != null;
      
      // Allow create if user is authenticated and is the review author
      allow create: if request.auth != null 
        && request.auth.uid == request.resource.data.userId
        && isValidReview(request.resource.data);
      
      // Allow update if user owns the review OR is the product owner (for artisan responses)
      allow update: if request.auth != null && (
        request.auth.uid == resource.data.userId ||
        isProductOwner(request.auth.uid, resource.data.productId)
      );
      
      // Allow delete only by review owner
      allow delete: if request.auth != null 
        && request.auth.uid == resource.data.userId;
    }
    
    // ============ NOTIFICATION SYSTEM ============
    // Push notification requests - Allow authenticated users to create, Cloud Functions to manage
    match /push_notification_requests/{requestId} {
      // Authenticated users can create notification requests
      allow create: if request.auth != null;
      
      // Only Cloud Functions can read/update/delete (for processing)
      allow read, update, delete: if false;
    }
    
    // User notifications - Personalized access
    match /user_notifications/{userId}/notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Cloud Functions can create notifications for users
      allow create: if false; // Only Cloud Functions should create
      
      // Users can update (mark as read, etc.) their own notifications
      allow update: if request.auth != null && 
                   request.auth.uid == userId &&
                   onlyUpdatingNotificationStatus(request.resource.data, resource.data);
      
      // Users can delete their own notifications
      allow delete: if request.auth != null && request.auth.uid == userId;
    }
    
    // FCM tokens storage in users collection
    match /users/{userId} {
      // Users can read/write their own profile and FCM token
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Cloud Functions can read user data for notifications
      allow read: if false; // Cloud Functions have admin access
    }
    
    // Notification settings per user
    match /notification_settings/{userId} {
      // Users can manage their own notification preferences
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // ============ HELPER FUNCTIONS ============
    // Review validation function
    function isValidReview(reviewData) {
      return reviewData.rating >= 1 
        && reviewData.rating <= 5
        && reviewData.comment.size() >= 10
        && reviewData.comment.size() <= 500
        && reviewData.userId == request.auth.uid;
    }
    
    // Check if user is the product owner
    function isProductOwner(userId, productId) {
      return exists(/databases/$(database)/documents/products/$(productId)) &&
        get(/databases/$(database)/documents/products/$(productId)).data.artisanId == userId;
    }
    
    // Check if only rating fields are being updated on products
    function onlyUpdatingRatingFields(newData, oldData) {
      return newData.diff(oldData).affectedKeys().hasOnly(['rating', 'reviewCount', 'updatedAt']);
    }
    
    // Check if only inventory fields are being updated (for order placement)
    function validateInventoryUpdate(newData, oldData) {
      // Only allow updates to stock quantity and related fields during order placement
      return newData.diff(oldData).affectedKeys().hasOnly(['stockQuantity', 'updatedAt']) &&
             // Ensure critical fields remain unchanged
             newData.artisanId == oldData.artisanId &&
             newData.name == oldData.name &&
             newData.price == oldData.price &&
             // Stock quantity should only decrease (not increase unless it's the owner)
             newData.stockQuantity <= oldData.stockQuantity;
    }
    
    // Check if only notification status fields are being updated
    function onlyUpdatingNotificationStatus(newData, oldData) {
      return newData.diff(oldData).affectedKeys().hasOnly(['isRead', 'readAt', 'updatedAt']);
    }

    // ============ FAQ MANAGEMENT ============
    // FAQs Collection - Admin and user access
    match /faqs/{faqId} {
      // Allow read access to all authenticated users for active FAQs
      allow read: if request.auth != null && 
                 resource.data.isActive == true;
      
      // Allow admin users to create/update/delete FAQs
      // For now, allow any authenticated user to manage FAQs (can be restricted later)
      allow create, update, delete: if request.auth != null;
    }
    
    // FAQ Feedback Collection
    match /faq_feedback/{feedbackId} {
      // Users can read their own feedback
      allow read: if request.auth != null && 
                 request.auth.uid == resource.data.userId;
      
      // Users can create feedback for any FAQ
      allow create: if request.auth != null && 
                   request.auth.uid == request.resource.data.userId;
      
      // Users can update/delete their own feedback
      allow update, delete: if request.auth != null && 
                           request.auth.uid == resource.data.userId;
    }
    
    // FAQ Analytics Collection
    match /faq_analytics/{faqId} {
      // Allow read access for analytics
      allow read: if request.auth != null;
      
      // Allow system updates for analytics
      allow create, update: if request.auth != null;
    }
    
    // ============ FALLBACK RULES ============
    // General authenticated access for other collections
    match /{document=**} {
      allow read: if request.auth != null;
      allow write: if false; // Explicit permissions required
    }
  }
}